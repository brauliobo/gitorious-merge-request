#!/usr/bin/env ruby

require 'rubygems'
require 'bundler/setup'
require 'highline/import'
Bundler.require

SubCommands = %w(new show)
global_opts = Trollop::options do
  version "gitorious-merge-request 1.0.0"
  banner <<-EOS
Manage Gitorious' merge requests

Usage:
  gitorious-merge-request command [options]
  List of available commands: #{SubCommands.join ' '}.
  Use 'command --help' for command usage.
EOS
  stop_on SubCommands
end

def login_opts
  opt :email, "Email for login", :short => 'e', :type => String
end

cmd = ARGV.shift # get the subcommand
cmd_opts = 
  case cmd
  when 'new' 
    Trollop::options do
      banner <<-EOS
new: create new merge request

Usage:
  gitorious-merge-request new [options]
  where [options] are:
EOS

      login_opts
      opt :summary, "Summary", :short => 's', :type => String
      opt :proposal, "Proposal", :short => 'p', :type => String
      opt :forked_repo, "Forked repo id (e.g. ~brauliobo/noosfero/brauliobos-noosfero)", :short => 'f', :type => String
      opt :forked_branch, "Forked branch", :short => 'a', :type => String
      opt :target_repo, "Target repo id (e.g. noosfero/noosfero)", :short => 't', :type => String
      opt :target_branch, "Target branch", :short => 'b', :type => String
    end
  when 'show'
    Trollop::options do
      opt :code, "Repository and merge request id (e.g. noosfero/noosfero:248)", :type => String
    end
  else
    Trollop::die "use one of the subcommands: #{SubCommands.join ' '}"
  end

def login
  password = ask('Password:'){ |q| q.echo = false }

  puts 'Login...'
  page = @mechanize.get 'https://gitorious.org/login'
  form = page.forms.first
  fields = form.fields
  fields.find{ |f| f.name == 'email' }.value = @email
  fields.find{ |f| f.name == 'password' }.value = password
  page = form.submit

  raise "Can't login" unless page.content.include?('Logged in successfully')
end

def cmd_new opts
  Trollop::die :email, "must exist" unless opts[:email]
  Trollop::die :summary, "must exist" unless opts[:summary]
  Trollop::die :forked, "must exist" unless opts[:forked_repo]
  Trollop::die :forked_branch, "must exist" unless opts[:forked_branch]
  Trollop::die :target, "must exist" unless opts[:target_repo]
  Trollop::die :target_branch, "must exist" unless opts[:target_branch]

  @email = opts[:email]
  @summary = opts[:summary]
  @proposal = opts[:proposal]
  @forked_repo = opts[:forked_repo]
  @forked_branch = opts[:forked_branch]
  @target_repo = opts[:target_repo]
  @target_branch = opts[:target_branch]

  def ending_commit(target_id)
    forked_repo = @forked_repo.split('/')[1,2].join('/')

    puts "Selecting last commit"
    page = @mechanize.post "https://gitorious.org/#{forked_repo}/merge_requests/commit_list", {
      'authenticity_token' => @authenticity_token,
      'merge_request[target_repository_id]' => target_id, 
      'merge_request[target_branch]' => @target_branch,
      'merge_request[source_branch]' => @forked_branch}

      # TODO: give option to select
      first_commit = page.parser.css('#commit_0 input').first
      raise 'No commit to merge' unless first_commit
      first_commit.attr 'value'
  end

  def merge_request
    forked_repo = @forked_repo.split('/')[1,2].join('/')
    target_repo = @target_repo.split('/').last

    puts "Opening merge request page"
    page = @mechanize.get "https://gitorious.org/#{forked_repo}/merge_requests/new"
    form = page.form_with :id => 'new_merge_request'

    form.set_fields 'merge_request[summary]' => @summary

    @authenticity_token = form.fields.find{ |f| f.name == 'authenticity_token' }.value

    target_option = page.parser.css('#merge_request_target_repository_id option').find{ |o| o.text == target_repo }
    raise "Can't find target repository" unless target_option
    target_id = target_option.attr('value')
    form.set_fields 'merge_request[target_repository_id]' => target_id

    target_branch_option = page.parser.css("#merge_request_target_branch option[value=#{@target_branch}]").first
    raise "Can't find target branch" unless target_branch_option
    form.set_fields 'merge_request[target_branch]' => @target_branch

    forked_branch_option = page.parser.css("#merge_request_source_branch option[value=#{@forked_branch}]").first
    raise "Can't find forked branch" unless forked_branch_option
    form.set_fields 'merge_request[source_branch]' => @forked_branch

    commit = ending_commit target_id
    form.add_field! 'merge_request[ending_commit]', commit

    page = form.submit
    pp page.content
  end

  login
  merge_request
end

def cmd_show opts
  @code = opts[:code]

  raise "can't parse code" unless @code =~ /(.+):(\d+)/
  repo = $1
  id = $2.to_i

  page = @mechanize.get "https://gitorious.org/#{repo}/merge_requests/#{id}"

  raise "can't grab summary" unless page.parser.css('#content h1').first.text =~ /[^#]+ #\d+: (.+)/
  summary = $1
  proposal = page.parser.css('.proposal').first.text

  lis = page.parser.css('ul.meta li')
  raise "can't get meta content" if lis.empty?

  a = lis[0].css('a').last
  requester = "#{a.text} (http://gitorious.org#{a.attr('href')})"

  puts <<-EOS
Requester: #{requester}

Summary: #{summary}
Proposal:
#{proposal.strip}

EOS
end

@mechanize = Mechanize.new
send "cmd_#{cmd}", cmd_opts



